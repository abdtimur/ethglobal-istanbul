use async_io_stream::IoStream;
use eyre::eyre;
use futures_util::AsyncWriteExt;
use serde::{Deserialize, Serialize};
use tlsn_core::proof::TlsProof;
use wasm_bindgen::prelude::*;
use web_time::Instant;
use ws_stream_wasm::{WsMeta, WsStreamIo};

// https://github.com/GoogleChromeLabs/wasm-bindgen-rayon#setting-up
pub use wasm_bindgen_rayon::init_thread_pool;

/// Provides `println!(..)`-style syntax for `console.log` logging.
#[macro_export]
macro_rules! log {
    ( $( $t:tt )* ) => {
        web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}

fn set_panic_hook() {
    // When the `console_error_panic_hook` feature is enabled, we can call the
    // `set_panic_hook` function at least once during initialization, and then
    // we will get better error messages if our code ever panics.
    //
    // For more details see
    // https://github.com/rustwasm/console_error_panic_hook#readme
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}

#[wasm_bindgen]
pub async fn prover(input_json_str: &str) -> Result<String, JsValue> {
    set_panic_hook();

    let start_time = Instant::now();

    let opts: ProverOpts = serde_json::from_str(input_json_str)
        .map_err(|e| JsValue::from_str(&format!("failed to parse input JSON: {e}")[..]))?;
    log!("parse input JSON OK: {opts:?}");

    let proof_res = prover_internal(opts).await;
    log!("elapsed: {}s", start_time.elapsed().as_secs());

    let proof = proof_res.map_err(|e| JsValue::from_str(&format!("prover failed: {e}")[..]))?;
    log!("obtain proof OK");

    let proof_json_str = serde_json::to_string(&proof).map_err(|e| {
        JsValue::from_str(&format!("failed to serialize final proof content: {e}")[..])
    })?;
    log!("serialize final proof content OK");

    Ok(proof_json_str)
}

async fn prover_internal(opts: ProverOpts) -> eyre::Result<TlsProof> {
    let proxy_io_stream = connect_to_proxy(&opts.env.proxy_address, &opts.input.url)
        .await
        .map_err(|e| eyre!("connect to proxy failed: {e}"))?;

    log!("connect to proxy OK");

    // TODO:
    Err(eyre::eyre!("not implemented"))
}

async fn connect_to_proxy(
    proxy_address: &str,
    target_url: &str,
) -> eyre::Result<IoStream<WsStreamIo, Vec<u8>>> {
    let (_, proxy_ws_stream) = WsMeta::connect(proxy_address, None)
        .await
        .map_err(|e| eyre!("failed to connect to proxy: {e}"))?;

    log!("connect to proxy OK");

    let mut proxy_io_stream = proxy_ws_stream.into_io();

    // Set the target for proxying
    let url_json_bytes = serde_json::to_vec(target_url)
        .map_err(|e| eyre!("failed to serialize proxy target: {e}"))?;

    log!("serialize proxy target OK");

    proxy_io_stream
        .write_all(&url_json_bytes)
        .await
        .map_err(|e| eyre!("failed to set proxy target: {e}"))?;

    log!("set proxy target OK");

    Ok(proxy_io_stream)
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProverOpts {
    pub env: ProverEnv,
    pub input: ProverInput,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProverEnv {
    pub max_transcript_size: usize, // NOTE: only 1 << 14 for now
    pub proxy_address: String,
    pub notary_address: String,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProverInput {
    pub method: String, // NOTE: only GET for now
    pub url: String,
    pub headers: Vec<Header>,
    pub body: Option<Vec<u8>>, // NOTE: only None for now
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Header {
    pub name: String,
    pub value: String,
}

/// Response object of the /session API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationSessionResponse {
    /// Unique session id that is generated by notary and shared to prover
    pub session_id: String,
}

/// Request object of the /session API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationSessionRequest {
    pub client_type: ClientType,
    /// Maximum transcript size in bytes
    pub max_transcript_size: Option<usize>,
}

/// Types of client that the prover is using
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ClientType {
    /// Client that has access to the transport layer
    Tcp,
    /// Client that cannot directly access transport layer, e.g. browser extension
    Websocket,
}

/// Request query of the /notarize API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NotarizationRequestQuery {
    /// Session id that is returned from /session API
    pub session_id: String,
}
